---
title : "Работа сервера Nginx и алгоритмов выбора блока расположения"
layout: post
tags: tutorial labnol
post_inspiration: https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms-ru
image: "https://sergio.afanou.com/assets/images/image-midres-27.jpg"
---

<h3 id="Введение">Введение</h3>

<p>Nginx — один из самых популярных веб-серверов в мире. Он может успешно выдерживать высокую нагрузку с множеством одновременных подключений клиентов и функционировать как веб-сервер, почтовый сервер или обратный прокси-сервер.</p>

<p>В этом учебном модуле мы обсудим некоторые скрытые аспекты, определяющие, как Nginx обрабатывает запросы клиентов. Понимание этих идей поможет избежать догадок при проектировании сервера и блоков расположения, а также сделать обработку запросов более предсказуемой.</p>

<h2 id="Конфигурации-блока-nginx">Конфигурации блока Nginx</h2>

<p>Nginx логически разделяет на блоки конфигурации, обслуживающие разные виды контента, и размещает эти блоки в иерархической структуре. При каждом поступлении клиентского запроса Nginx определяет, какие блоки конфигурации следует использовать для его обработки. Об этом процессе мы и расскажем в этом учебном модуле.</p>

<p>В первую очередь мы расскажем о блоках <strong>server</strong> и <strong>location</strong>.</p>

<p>Блок server — это часть конфигурации Nginx, которая определяет виртуальный сервер, используемый для обработки запросов заданного типа.  Администраторы часто настраивают несколько блоков server и определяют, какой из них будет отвечать за конкретное соединение на основании запрошенного доменного имени, порта и IP-адреса.</p>

<p>Блок location располагается внутри блока server и определяет, как Nginx будет обрабатывать запросы различных ресурсов и URI для родительского сервера.  Администратор, использующий эти блоки, может разделить пространство URI любым удобным способом.  Это чрезвычайно гибкая модель.</p>

<h2 id="Как-nginx-решает-какой-серверный-блок-будет-обрабатывать-запрос">Как Nginx решает, какой серверный блок будет обрабатывать запрос</h2>

<p>Поскольку Nginx разрешает администратору определять несколько серверных блоков, работающих как отдельные экземпляры виртуального веб-сервера, ему требуется процедура, определяющая, какие серверные блоки будут использоваться для выполнения запроса.</p>

<p>Для этого используется фиксированная система проверок, служащих для подбора оптимального совпадения.  Главные директивы серверного блока, которые учитывает Nginx в этом процессе — директивы <code>listen</code> и <code>server_name</code>.</p>

<h3 id="Синтаксический-анализ-директивы-quot-listen-quot-для-поиска-возможных-совпадений">Синтаксический анализ директивы &ldquo;listen&rdquo; для поиска возможных совпадений</h3>

<p>Прежде всего, Nginx смотрит IP-адрес и порт запроса. Он сверяет их с директивой <code>listen</code> каждого сервера, создавая список серверных блоков, которые могут обработать данный запрос.</p>

<p>Директива <code>listen</code> обычно определяет IP-адрес и порт, на которые отвечает серверный блок. Любой серверный блок, не включающий директиву <code>listen</code>, по умолчанию имеет параметры прослушивания <code>0.0.0.0:80</code> (или <code>0.0.0.0:8080</code>, если Nginx запускается обычным пользователем без привилегий root). Это позволяет данным блокам отвечать на запросы любого интерфейса на порту 80, но данное значение по умолчанию не имеет большого веса в процессе выбора сервера.</p>

<p>Директиву <code>listen</code> можно задать следующим образом:</p>

<ul>
<li>Сочетание IP-адреса и порта.</li>
<li>Отдельный IP-адрес, который будет прослушивать порт 80 по умолчанию.</li>
<li>Одиночный порт, который прослушивает каждый интерфейс этого порта.</li>
<li>Путь к сокету Unix.</li>
</ul>

<p>Последняя опция обычно влияет только на передачу запросов между разными серверами.</p>

<p>Вначале Nginx попробует выбрать серверный блок, на который будет отправлен запрос, на основе специфики директивы <code>listen</code>, используя следующие правила:</p>

<ul>
<li>Nginx преобразует все неполные директивы <code>listen</code>, заменяя отсутствующие значения значениями по умолчанию так, что каждый блок оценивается по IP-адресу и порту. Вот несколько примеров такого преобразования:

<ul>
<li>Блок без директивы <code>listen</code> использует значение <code>0.0.0.0:80</code>.</li>
<li>Блок с заданным IP-адресом <code>111.111.111.111</code> без номера порта использует значение <code>111.111.111.111:80</code></li>
<li>Блок с заданным портом <code>8888</code> без IP-адреса использует значение <code>0.0.0.0:8888</code></li>
</ul></li>
<li>Затем Nginx пытается собрать список серверных блоков, наиболее точно соответствующих запросу по IP-адресу и порту. Это означает, что блок со значением IP-адреса <code>0.0.0.0</code> (соответствующим любому интерфейсу) не будет выбран, если будут найден блоки, где указан конкретный IP-адрес. Точное совпадение порта обязательно в любом случае.</li>
<li>Если будет найдено одно наиболее точное совпадение, запрос будет обработан с помощью данного серверного блока. Если будет найдено несколько серверных блоков с одинаковым уровнем соответствия, Nginx начнет оценку директивы <code>server_name</code> каждого серверного блока.</li>
</ul>

<p>Важно понимать, что Nginx будет использовать для оценки директиву <code>server_name</code>, только если будет нужно выбрать из серверных блоков с одинаковым уровнем соответствия в директиве <code>listen</code>.  Например, в случае размещения <code>example.com</code> на порту <code>80</code> с IP-адресом <code>192.168.1.10</code>, запрос <code>example.com</code> всегда будет обслуживаться первым блоком из данного примера невзирая на директиву <code>server_name</code> во втором блоке.</p>
<pre class="code-pre "><code>server {
    listen 192.168.1.10;

    . . .

}

server {
    listen 80;
    server_name example.com;

    . . .

}
</code></pre>
<p>В случае равного уровня соответствия нескольких серверных блоков следующим шагом будет проверка директивы <code>server_name</code>.</p>

<h3 id="Проверка-директивы-quot-server_name-quot-для-выбора-совпадения">Проверка директивы &ldquo;server_name&rdquo; для выбора совпадения</h3>

<p>Для оценки запросов с равноценным уровнем соответствия директив <code>listen</code> Nginx проверяет заголовок &ldquo;Host&rdquo; запроса. Это значение соответствует домену или IP-адресу, к которым клиент пытается подключиться.</p>

<p>Nginx пытается подобрать наилучшее значение на основе директивы <code>server_name</code> в каждом из серверных блоков, которые являются наилучшим соответствием.  Nginx оценивает их по следующей формуле:</p>

<ul>
<li>Nginx сначала попытается найти серверный блок со значением <code>server_name</code>, <em>точно</em> соответствующим значению в заголовке запроса &ldquo;Host&rdquo;. Если такой элемент найден, для обслуживания запроса будет использован соответствующий блок. Если найдется несколько точных совпадений, используется <strong>первый</strong> вариант.</li>
<li>Если точных совпадений найдено не будет, Nginx будет пытаться найти серверный блок с директивой <code>server_name</code>, соответствующей первому подстановочному символу (обозначается символом <code>*</code> в начале названия в конфигурации). Если такой блок будет найден, он будет использоваться для обслуживания запроса. Если будут найдены несколько совпадений, для обслуживания запроса будет использоваться <strong>самое длинное</strong> из них.</li>
<li>Если совпадений с начальным подстановочным символом не будет, Nginx начнет искать серверный блок со значением <code>server_name</code>, соответствующим конечному подстановочному символу (указывается именем сервера с символом <code>*</code> в конфигурации). Если такой блок будет найден, он будет использоваться для обслуживания запроса. Если будут найдены несколько совпадений, для обслуживания запроса будет использоваться <strong>самое длинное</strong> из них.</li>
<li>Если совпадений с использованием конечного подстановочного символа найдено не будет, Nginx будет оценивать серверные блоки, определяющие <code>server_name</code>, с помощью регулярных выражений (обозначаются символом <code>~</code> перед названием). Для выполнения запроса будет использоваться <strong>первая</strong> директива <code>server_name</code> с регулярным выражением, соответствующим заголовку &ldquo;Host&rdquo;.</li>
<li>Если совпадений с регулярными выражениями не будет, Nginx выберет серверный блок по умолчанию для этого IP-адреса и порта.</li>
</ul>

<p>Каждая комбинация IP-адреса и порта имеет серверный блок, который будет по умолчанию использоваться, если с помощью вышеописанных методов не удастся принять решение. Для комбинации IP-адреса и порта это будет первый блок в конфигурации или блок, содержащий опцию <code>default_server</code> в директиве <code>listen</code> (имеет приоритет перед алгоритмом на основе первого найденного). Для каждой комбинации IP-адреса и порта может существовать только одна декларация <code>default_server</code>.</p>

<h3 id="Примеры">Примеры</h3>

<p>Если будет определена директива <code>server_name</code>, которая точно соответствует значению заголовка &ldquo;Host&rdquo;, для обработки запроса будет выбран соответствующий серверный блок.</p>

<p>В этом примере, если для запроса задать заголовку &ldquo;Host&rdquo; значение &ldquo;host1.example.com&rdquo;, будет выбран второй сервер:</p>
<pre class="code-pre "><code>server {
    listen 80;
    server_name *.example.com;

    . . .

}

server {
    listen 80;
    server_name host1.example.com;

    . . .

}
</code></pre>
<p>Если точного совпадения найдено не будет, Nginx проверяет наличие параметра <code>server_name</code> с подходящим начальным подстановочным символом. Для выполнения запроса будет выбрано самое длинное совпадение, начинающееся с подстановочного символа.</p>

<p>В этом примере, если заголовок &ldquo;Host&rdquo; запроса будет иметь значение &ldquo;<a href="http://www.example.org">www.example.org</a>&rdquo;, будет выбран второй серверный блок:</p>
<pre class="code-pre "><code>server {
    listen 80;
    server_name www.example.*;

    . . .

}

server {
    listen 80;
    server_name *.example.org;

    . . .

}

server {
    listen 80;
    server_name *.org;

    . . .

}
</code></pre>
<p>Если не будет найдено совпадения с начальным подстановочным символом, Nginx проверит наличие совпадения с подстановочным символом в конце выражения. На этом шаге для обслуживания запроса выбирается наиболее длинное совпадение, заканчивающееся подстановочным символом.</p>

<p>Например, если заголовок &ldquo;Host&rdquo; запроса имеет значение &ldquo;<a href="http://www.example.com">www.example.com</a>&rdquo;, будет выбран третий серверный блок:</p>
<pre class="code-pre "><code>server {
    listen 80;
    server_name host1.example.com;

    . . .

}

server {
    listen 80;
    server_name example.com;

    . . .

}

server {
    listen 80;
    server_name www.example.*;

    . . .

}
</code></pre>
<p>Если совпадений с подстановочными символами найдено не будет, Nginx попытается подобрать директивы <code>server_name</code>, использующие регулярные выражения. <em>Первое</em> совпадающее регулярное выражение будет выбрано для реагирования на запрос.</p>

<p>Например, если заголовок &ldquo;Host&rdquo; будет иметь значение &ldquo;<a href="http://www.example.com">www.example.com</a>&rdquo;, для выполнения запроса будет выбран второй серверный блок:</p>
<pre class="code-pre "><code>server {
    listen 80;
    server_name example.com;

    . . .

}

server {
    listen 80;
    server_name ~^(www|host1).*\.example\.com$;

    . . .

}

server {
    listen 80;
    server_name ~^(subdomain|set|www|host1).*\.example\.com$;

    . . .

}
</code></pre>
<p>Если никакие из вышеуказанных шагов не обеспечат выполнение запроса, запрос будет передан серверу <em>по умолчанию</em> для соответствующей комбинации IP-адреса и порта.</p>

<h2 id="Совпадающие-блоки-расположения">Совпадающие блоки расположения</h2>

<p>Аналогично процессу, который Nginx использует для выбора серверного блока для обработки запроса, Nginx также имеет стабильный алгоритм для определения блока расположения сервера, который будет использоваться для обработки запросов.</p>

<h3 id="Синтаксис-блока-расположения">Синтаксис блока расположения</h3>

<p>Прежде чем рассказывать о том, как Nginx определяет, какой блок расположения использовать для обработки запросов, давайте посмотрим синтаксис, который можно увидеть в определениях блоков расположения. Блоки расположения находятся в серверных блоках (или других блоках расположения) и используются, чтобы решить, как обрабатывать URI запроса (часть запроса после доменного имени или IP-адрес/порта).</p>

<p>Блоки расположения обычно принимают следующую форму:</p>
<pre class="code-pre "><code>location <span class="highlight">optional_modifier</span> <span class="highlight">location_match</span> {

    . . .

}
</code></pre>
<p><code><span class="highlight">location_match</span></code> выше определяет, что Nginx следует проверять в отношении URI запроса. Наличие или отсутствие модификатора в примере выше влияет на то, как Nginx пытается подобрать соответствие блока расположения. Далее перечислены модификаторы, используемые для интерпретации блока расположения:</p>

<ul>
<li><strong>(нет)</strong>: если модификаторов нет, расположение определяется как соответствие <em>префикса</em>. Это означает, что расположение будет сверяться с началом URI запроса для определения совпадения.</li>
<li><strong><code>=</code></strong>: если используется знак равенства, блок будет считаться совпадающим, если URI запроса точно соответствует указанному расположению.</li>
<li><strong><code>~</code></strong>: знак тильды означает, что это расположение будет интерпретироваться как совпадение с регулярным выражением с учетом регистра.</li>
<li><strong><code>~*</code></strong>: знак тильды со звездочкой означают, что блок расположения будет интерпретироваться как совпадение с регулярным выражением без учета регистра.</li>
<li><strong><code>^~</code></strong>: знак елочки с тильдой означают, что если этот блок будет выбран как лучшее соответствие без регулярных выражений, сопоставление по регулярным выражением проводиться не будет.</li>
</ul>

<h3 id="Примеры-демонстрирующие-синтаксис-блока-расположения">Примеры, демонстрирующие синтаксис блока расположения</h3>

<p>В качестве примера соответствия префиксов можно выбрать следующий блок расположения для реагирования на URI запроса вида <code>/site</code>, <code>/site/page1/index.html</code> или <code>/site/index.html</code>:</p>
<pre class="code-pre "><code>location /site {

    . . .

}
</code></pre>
<p>Как пример точного соответствия URI запроса, этот блок всегда будет использоваться для ответа на URI запроса вида <code>/page1</code>. Он <strong>не</strong> будет использоваться для ответа на URI запроса <code>/page1/index.html</code>. Помните, что если выбран этот блок, и если запрос выполняется с использованием страницы индекса, произойдет внутренняя переадресация на другое расположение, которое фактически и будет обрабатывать запрос:</p>
<pre class="code-pre "><code>location = /page1 {

    . . .

}
</code></pre>
<p>Как пример расположения, которое следует интерпретировать как регулярное выражение с учетом регистра, этот блок можно использовать для обработки запросов <code>/tortoise.jpg</code>, но <strong>не</strong> запросов <code>/FLOWER.PNG</code>:</p>
<pre class="code-pre "><code>location ~ \.(jpe?g|png|gif|ico)$ {

    . . .

}
</code></pre>
<p>Ниже показан похожий блок, поддерживающий сопоставление без учета регистра.  Этот блок может обрабатывать как запросы <code>/tortoise.jpg</code>, так <em>и</em> запросы <code>/FLOWER.PNG</code>:</p>
<pre class="code-pre "><code>location ~* \.(jpe?g|png|gif|ico)$ {

    . . .

}
</code></pre>
<p>Наконец, этот блок не даст выполнять сопоставление с регулярными выражениями, если будет признан лучшим совпадением без регулярного выражения.  Он сможет обрабатывать запросы <code>/costumes/ninja.html</code>:</p>
<pre class="code-pre "><code>location ^~ /costumes {

    . . .

}
</code></pre>
<p>Как видите, модификаторы показывают, как следует интерпретировать блок расположения.  Однако это <em>не</em> говорит нам, какой алгоритм Nginx использует для определения блока расположения, в который будет отправлен запрос.  Этот вопрос мы рассмотрим далее.</p>

<h3 id="Как-nginx-выбирает-расположение-для-обработки-запросов">Как Nginx выбирает расположение для обработки запросов</h3>

<p>Nginx выбирает расположение, которое будет использоваться для обработки запроса аналогично выбору серверного блока. Он выполняет процесс, определяющий наилучший блок расположения для любого заданного запроса.  Понимание этого процесса очень важно для возможности надежной и точной настройки Nginx.</p>

<p>Учитывая описанные выше типы деклараций расположения, Nginx оценивает возможные контексты расположения, сравнивая URI запроса с каждым расположением.  Для этого используется следующий алгоритм:</p>

<ul>
<li>Для начала Nginx проверяет все совпадения расположения на базе префиксов (все типы расположений без регулярных выражений). Каждое расположение сверяется с полным URI запроса.</li>
<li>Во-первых, Nginx ищет точное совпадение. Если блок расположения, использующий модификатор <code>=</code>, будет точно соответствовать URI запроса, этот блок расположения сразу же будет выбран для обслуживания запроса.</li>
<li>Если точное соответствие (с модификатором <code>=</code>) блока расположения найдено не будет, Nginx перейдет к оценке неточных префиксов.  Он определит самое длинное совпадающее расположение префикса для указанного URI запроса, которое будет оценено следующим образом:

<ul>
<li>Если совпадающее расположение с самым длинным префиксом имеет модификатор <code>^~</code>, Nginx немедленно прекращает поиск и выбирает это расположение для обслуживания запроса.</li>
<li>Если совпадающее расположение с самым длинным префиксом <em>не имеет</em> модификатор <code>^~</code>, Nginx временно сохраняет его, чтобы можно было сместить фокус поиска.</li>
</ul></li>
<li>После определения и сохранения совпадающего расположения с самым длинным префиксом Nginx переходит к оценке расположений с регулярными выражениями (с учетом регистра и без учета регистра). Если расположения с регулярными выражениями будут найдены <em>внутри</em> совпадающего расположения с самым длинным префиксом, Nginx переместит их наверх списка расположений с регулярными выражениями для проверки. Затем Nginx попытается подбирать расположения регулярных выражений последовательно. <strong>Первое</strong> регулярное выражение, соответствующее URI запроса, будет сразу же выбрано для обслуживания запроса.</li>
<li>Если не будет найдено никаких расположений регулярных выражений, соответствующих URI запроса, для обслуживания запроса будет выбрано ранее сохраненное расположение префикса.</li>
</ul>

<p>Важно понимать, что по умолчанию Nginx будет отдавать совпадениям регулярных выражений приоритет перед совпадениями префиксов. Однако он вначале <em>оценивает</em> расположения префиксов, позволяя администратору переопределить этот приоритет, используя модификаторы <code>=</code> и <code>^~</code> при определении расположения.</p>

<p>Также важно отметить, что хотя расположения префиксов обычно определяются на основе самого длинного и точного совпадения, оценка регулярных выражений останавливается при обнаружении первого совпадения. Это означает, что расположение в конфигурации важно для расположения регулярных выражений.</p>

<p>Наконец, важно понимать, что совпадения регулярных выражений <em>с</em> самым длинным совпадением префикса будут иметь больший приоритет при оценке регулярных выражений Nginx.  Они будут оцениваться по порядку до начала оценки любых других совпадений регулярных выражений. Максим Дунин, разработчик Nginx, дающий очень много полезных советов, объясняет в <a href="https://www.ruby-forum.com/topic/4422812#1136698">этом сообщении</a> принципы работы данной части алгоритма выбора.</p>

<h3 id="Когда-оценка-блока-расположения-переходит-к-другим-расположениям">Когда оценка блока расположения переходит к другим расположениям?</h3>

<p>Обычно, когда для обслуживания запроса выбирается блок расположения, запрос полностью обрабатывается в этом контексте, начиная с этого момента.  Обработка запроса определяется только выбранным расположением и унаследованными директивами без вмешательства других родственных блоков расположения.</p>

<p>Хотя это общее правило, позволяющее прогнозируемо проектировать блоки расположения, важно понимать, что иногда определенные директивы в выбранном расположении могут активировать новый поиск расположения. Исключения из правила использования только одного блока расположения могут влиять на фактический процесс обработки запроса и не соответствовать вашим ожиданиям при проектировании блоков расположения.</p>

<p>Вот некоторые директивы, которые могут активировать подобную внутреннюю переадресацию:</p>

<ul>
<li><strong>index</strong></li>
<li><strong>try_files</strong></li>
<li><strong>rewrite</strong></li>
<li><strong>error_page</strong></li>
</ul>

<p>Давайте вкратце рассмотрим их.</p>

<p>Директива <code>index</code> всегда вызывает внутреннюю переадресацию, если используется для обработки запроса.  Точные совпадения расположения часто используются для ускорения процесса выбора с немедленным завершением алгоритма. Однако, если точное совпадение расположения представляет собой <em>каталог</em>, есть вероятность, что запрос будет переадресован для фактической обработки в другое расположение.</p>

<p>В этом примере первому расположению соответствует URI запроса <code>/exact</code>, но для обработки запроса директива <code>index</code>, унаследованная блоком, активирует внутреннюю переадресацию во второй блок:</p>
<pre class="code-pre "><code>index index.html;

location = /exact {

    . . .

}

location / {

    . . .

}
</code></pre>
<p>Если в примере выше вы захотите ограничить исполнение первым блоком, вам нужно будет подобрать другой метод выполнения запроса каталога.  Например, вы можете задать недопустимый <code>index</code> этого блока и включить <code>autoindex</code>:</p>
<pre class="code-pre "><code>location = /exact {
    index nothing_will_match;
    autoindex on;
}

location  / {

    . . .

}
</code></pre>
<p>Этот способ позволит предотвратить переключение контекста <code>index</code>, но в большинстве конфигураций он не будет полезен.  Более точное совпадение каталогов может помочь в таких случаях как перезапись запроса (в результате чего также выполняется новый поиск расположения).</p>

<p>Также расположение обработки может переоцениваться при использовании директивы <code>try_files</code>.  Эта директива предписывает Nginx проверить существование набора файлов или каталогов с определенным именем.  Последним параметром может быть URI, на который Nginx осуществляет внутреннюю переадресацию.</p>

<p>Рассмотрим следующую конфигурацию:</p>
<pre class="code-pre "><code>root /var/www/main;
location / {
    try_files $uri $uri.html $uri/ /fallback/index.html;
}

location /fallback {
    root /var/www/another;
}
</code></pre>
<p>В примере выше, если мы делаем запрос <code>/blahblah</code>, запрос получит первое расположение.  Оно попытается найти файл с именем <code>blahblah</code> в каталоге <code>/var/www/main</code>.  Если это не получится сделать, будет выполнен поиск файла с именем <code>blahblah.html</code>.  Затем будет выполнен поиск каталога <code>blahblah/</code> в каталоге <code>/var/www/main</code>.  Если все эти попытки закончатся неудачно, будет выполнена переадресация на <code>/fallback/index.html</code>.  В этом случае будет активирован другой поиск расположения, который будет перехвачен вторым блоком расположения.  Он выдаст файл <code>/var/www/another/fallback/index.html</code>.</p>

<p>Также смена блока расположения возможна при использовании директивы <code>rewrite</code>.  При использовании параметра <code>last</code> с директивой <code>rewrite</code> или при ее использовании без каких-либо параметров Nginx выполняет поиск нового подходящего расположения на основе результатов перезаписи.</p>

<p>Например, если мы изменим последний пример и включим в него директиву rewrite, мы увидим, что запрос будет иногда передаваться во второе расположение без использования директивы <code>try_files</code>:</p>
<pre class="code-pre "><code>root /var/www/main;
location / {
    rewrite ^/rewriteme/(.*)$ /$1 last;
    try_files $uri $uri.html $uri/ /fallback/index.html;
}

location /fallback {
    root /var/www/another;
}
</code></pre>
<p>В примере выше запрос <code>/rewriteme/hello</code> будет первоначально обработан первым блоком расположения.  Он будет перезаписан в <code>/hello</code>, и будет выполнен поиск расположения.  В этом случае совпадением опять будет первое расположение, и будет выполнена обычная обработка <code>try_files</code>, возможно с возвратом к <code>/fallback/index.html</code>, если ничего не будет найдено (посредством внутренней переадресации <code>try_files</code>, как описано выше).</p>

<p>Однако в случае запроса <code>/rewriteme/fallback/hello</code> первый блок опять будет соответствовать.  В этом случае снова будет применена перезапись, в данном случае на <code>/fallback/hello</code>.  Затем запрос будет выполнен вторым блоком расположения.</p>

<p>Похожая ситуация происходит с директивой <code>return</code> при отправке кодов состояния <code>301</code> или <code>302</code>.  В данном случае разница заключается в том, чтобы обработать совершенно новый запрос в форме внешней видимой переадресации.  Такая же ситуация может возникнуть с директивой <code>rewrite</code> при использовании флагов <code>redirect</code> или <code>permanent</code>.  Однако эти поиски расположения не должны быть неожиданными, поскольку внешняя видимая переадресация всегда приводит к созданию нового запроса.</p>

<p>Директива <code>error_page</code> может вызвать внутреннюю переадресацию, аналогичную созданной <code>try_files</code>.  Эта директива используется, чтобы определить, что должно происходить при получении определенных кодов состояния.  Она практически никогда не выполняется вместе с <code>try_files</code>, потому что обрабатывает весь жизненный цикл запроса.</p>

<p>Рассмотрим следующий пример:</p>
<pre class="code-pre "><code>root /var/www/main;

location / {
    error_page 404 /another/whoops.html;
}

location /another {
    root /var/www;
}
</code></pre>
<p>Каждый запрос, кроме начинающихся с <code>/another</code>, будет обрабатываться первым блоком, который будет выводить файлы из <code>/var/www/main</code>.  Однако, если файл не будет найден (статус 404), будет выполнена внутренняя переадресация на <code>/another/whoops.html</code>, в результате чего будет активирован новый поиск расположения, который попадет на второй блок.  Файл будет выводиться из <code>/var/www/another/whoops.html</code>.</p>

<p>Как видите, понимание обстоятельств, в которых Nginx активирует новый поиск расположения, может помочь прогнозировать поведение, которое вы будете наблюдать при отправке запросов.</p>

<h2 id="Заключение">Заключение</h2>

<p>Понимание способов обработки запросов клиентов в Nginx может значительно упростить работу администратора.  Вы сможете понимать, какой серверный блок будет выбирать Nginx в ответ на запрос каждого клиента.  Также вы поймете, как определить выбираемый блок расположения на основе URI запроса.  Понимание того, как Nginx выбирает разные блоки, позволит вам отслеживать применяемые Nginx контексты для обслуживания каждого запроса.</p>
