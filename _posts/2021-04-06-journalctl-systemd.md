---
title : "Использование Journalctl для просмотра журналов Systemd и выполнения операций с ними"
layout: post
tags: tutorial labnol
post_inspiration: https://www.digitalocean.com/community/tutorials/how-to-use-journalctl-to-view-and-manipulate-systemd-logs-ru
image: "https://sergio.afanou.com/assets/images/image-midres-51.jpg"
---

<h3 id="Введение">Введение</h3>

<p>Некоторые из наиболее привлекательных преимуществ <code>systemd</code> связаны с ведением журналов процессов и системных событий.  При использовании других систем журналы обычно распределяются по разным местам, обрабатываются различными демонами и инструментами, и их бывает сложно интерпретировать, когда они работают с несколькими приложениями. <code>Systemd</code> пытается устранить эти сложности, предоставляя решение централизованного управления для регистрации всех процессов ядра и пользовательской области.  Система, собирающая эти журналы и управляющая ими, называется журнальной системой.</p>

<p>Журнальная система реализована в форме демона <code>journald</code>, который обрабатывает все сообщения ядра, initrd, служб и т. д. В этом учебном руководстве мы покажем, как использовать утилиту <code>journalctl</code> для доступа данными в журнале и управления этими данными.</p>

<h2 id="Общая-идея">Общая идея</h2>

<p>Одна из целей журнальной системы <code>systemd</code> заключается в централизации управления журналами вне зависимости от источника сообщений.  Поскольку существенная часть процесса загрузки и управления службами выполняется процессом <code>systemd</code>, имеет смысл стандартизировать сбор данных для журналов и доступ к ним.  Демон <code>journald</code> собирает данные из всех доступных источников и сохраняет их в двоичном формате для удобного и динамичного управления ими.</p>

<p>Это дает нам ряд существенных преимуществ.  Взаимодействуя с данными через одну утилиту, администраторы могут динамически выводить данные журнала в соответствии с их потребностями.  Это могут быть как простые задачи, такие как просмотр данных предыдущей загрузки системы, так и более сложные задачи, например, комбинирование записей журналов двух связанных служб для устранения коммуникационной проблемы.</p>

<p>Хранение данных журнала в двоичном формате также означает, что данные можно отображать в произвольном виде в зависимости от того, что требуется в текущий момент.  Например, для каждодневного управления журналами вы можете использовать стандартный формат <code>syslog</code>, но если вы захотите составить график перебоев в работе служб, вы можете вывести все записи в формате объектов JSON для экспорта в приложение составления графиков.  Поскольку данные не записываются на диск в формате обычного текста, их не нужно будет конвертировать, если вам потребуется другой формат вывода.</p>

<p>Журнальную систему <code>systemd</code> можно использовать вместе с существующей реализацией <code>syslog</code>, или в качестве функциональной замены <code>syslog</code>, если вам это потребуется.  Хотя журнальная система <code>systemd</code> способна удовлетворить большинство потребностей администратора, ее также можно использовать в качестве дополнения к существующим механизмам ведения журнала.  Например, вы можете использовать централизованный сервер <code>syslog</code> для компиляции данных с нескольких серверов, но при этом также чередовать журналы нескольких служб одной системы с журналом <code>systemd</code>.  Объединив эти технологии, вы можете выполнить обе задачи.</p>

<h2 id="Настройка-времени-системы">Настройка времени системы</h2>

<p>Одно из преимуществ использования двоичного журнала заключается в возможности просмотра записей журнала как с локальным временем, так и с временем по Гринвичу (UTC).  По умолчанию <code>systemd</code> использует для отображения результатов локальное время.</p>

<p>В связи с этим, прежде чем мы начнем работу с журналом, нам нужно будет убедиться, что часовой пояс настроен правильно.  Пакет <code>systemd</code> включает инструмент <code>timedatectl</code>, который может помочь с этой задачей.</p>

<p>Прежде всего, нужно использовать опцию <code>list-timezones</code> для просмотра доступных часовых поясов:</p>
<pre class="code-pre "><code>timedatectl list-timezones
</code></pre>
<p>Эта опция выводит список часовых поясов, доступных в вашей системе.  Когда вы найдете часовой пояс, соответствующий расположению вашего сервера, вы сможете установить его с помощью опции<code>set-timezone</code>:</p>
<pre class="code-pre "><code>sudo timedatectl set-timezone <span class="highlight">zone</span>
</code></pre>
<p>Чтобы убедиться, что ваша система использует правильное время, воспользуйтесь командой <code>timedatectl</code> без опций или с опцией <code>status</code>.  Изображение на экране будет таким же:</p>
<pre class="code-pre "><code>timedatectl status
</code></pre><pre class="code-pre "><code>      <span class="highlight">Local time: Thu 2015-02-05 14:08:06 EST</span>
  Universal time: Thu 2015-02-05 19:08:06 UTC
        RTC time: Thu 2015-02-05 19:08:06
       Time zone: America/New_York (EST, -0500)
     NTP enabled: no
NTP synchronized: no
 RTC in local TZ: no
      DST active: n/a
</code></pre>
<p>В первой строке должно отображаться правильное время.</p>

<h2 id="Основы-просмотра-журнала">Основы просмотра журнала</h2>

<p>Чтобы просмотреть журналы, собранные демоном <code>journald</code>, используйте команду <code>journalctl</code>.</p>

<p>Когда эта команда используется отдельно, все записи журналов в системе будут выведены в многостраничном списке (обычно занимает <code>меньше</code> страницы), который вы сможете просматривать.  Самые старые записи будут отображаться сверху:</p>
<pre class="code-pre "><code>journalctl
</code></pre><pre class="code-pre "><code>-- Logs begin at Tue 2015-02-03 21:48:52 UTC, end at Tue 2015-02-03 22:29:38 UTC. --
Feb 03 21:48:52 localhost.localdomain systemd-journal[243]: Runtime journal is using 6.2M (max allowed 49.
Feb 03 21:48:52 localhost.localdomain systemd-journal[243]: Runtime journal is using 6.2M (max allowed 49.
Feb 03 21:48:52 localhost.localdomain systemd-journald[139]: Received SIGTERM from PID 1 (systemd).
Feb 03 21:48:52 localhost.localdomain kernel: audit: type=1404 audit(1423000132.274:2): enforcing=1 old_en
Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 2048 avtab hash slots, 104131 rules.
Feb 03 21:48:52 localhost.localdomain kernel: SELinux: 2048 avtab hash slots, 104131 rules.
Feb 03 21:48:52 localhost.localdomain kernel: input: ImExPS/2 Generic Explorer Mouse as /devices/platform/
Feb 03 21:48:52 localhost.localdomain kernel: SELinux:  8 users, 102 roles, 4976 types, 294 bools, 1 sens,
Feb 03 21:48:52 localhost.localdomain kernel: SELinux:  83 classes, 104131 rules

. . .
</code></pre>
<p>Вероятно у вас будет возможность прокрутки множества страниц данных, включая даже десятки тысяч строк, если <code>systemd</code> используется в вашей системе уже давно.  Это показывает, сколько данных доступно в базе данных журнала.</p>

<p>Данный формат будет знаком тем, кто привык к стандартным журналам <code>syslog</code>.  Однако при этом способе данные собираются из большего числа источников, чем поддерживают стандартные приложения <code>syslog</code>.  Журнальная система поддерживает журналы процесса начальной загрузки, ядра, initrd, стандартные журналы ошибок и вывода приложений и т. д.</p>

<p>Обратите внимание, что для всех временных меток используется локальное время. Эта возможность теперь доступна для всех записей журнала, потому что мы правильно настроили локальное время в нашей системе.  Все журналы отображаются с использованием этой новой информации.</p>

<p>Если вы хотите вывести временные метки в формате UTC, вы можете использовать флаг <code>--utc</code>:</p>
<pre class="code-pre "><code>journalctl --utc
</code></pre>
<h2 id="Фильтрация-журнала-по-времени">Фильтрация журнала по времени</h2>

<p>Хотя доступ к такому большому набору данных несомненно полезен, просмотреть и понять такое количество информации может быть очень сложно или даже невозможно.  Поэтому опции фильтрации входят в число наиболее значимых возможностей <code>journalctl</code>.</p>

<h3 id="Вывод-журналов-текущей-загрузки">Вывод журналов текущей загрузки</h3>

<p>Флаг <code>-b</code> — одна из самых простых опций, которой вы часто будете пользоваться.  С его помощью вы сможете вывести для просмотра все записи журнала, собранные с момента последней перезагрузки.</p>
<pre class="code-pre "><code>journalctl -b
</code></pre>
<p>Это поможет вам определять, какая информация важна для текущей среды, и управлять этой информацией.</p>

<p>Если вы не используете эту функцию и выводите данные более, чем за один день загрузок, вы увидите, что утилита <code>journalctl</code> вставляет примерно такую строку при каждом выключении системы:</p>
<pre class="code-pre "><code>. . .

-- Reboot --

. . .
</code></pre>
<p>Ее можно использовать в качестве логического разделителя информации между сеансами загрузки.</p>

<h3 id="Прошлые-загрузки">Прошлые загрузки</h3>

<p>Хотя чаще всего вам будут нужны данные по текущему сеансу загрузки системы, данные по прошлым сеансам также могут оказаться полезными.  Журнальная система может хранить данные множества сеансов загрузки, так что <code>journalctl</code> можно использовать для удобного вывода информации.</p>

<p>В некоторых дистрибутивах информация о предыдущих сеансах загрузки сохраняется по умолчанию, а в других эта возможность отключена.  Чтобы информация о сеансах загрузки не удалялась, вы можете создать каталог для хранения журналов с помощью следующей команды:</p>
<pre class="code-pre command prefixed"><code class="code-highlight language-bash"><ul class="prefixed"><li class="line" data-prefix="$">sudo mkdir -p /var/log/journal
</li></ul></code></pre>
<p>Также вы можете отредактировать файл конфигурации журнальной системы:</p>
<pre class="code-pre command prefixed"><code class="code-highlight language-bash"><ul class="prefixed"><li class="line" data-prefix="$">sudo nano /etc/systemd/journald.conf
</li></ul></code></pre>
<p>В разделе <code>[Journal]</code> установите для опции <code>Storage=</code> значение persistent, чтобы включить постоянное хранение журналов:</p>
<div class="code-label " title="/etc/systemd/journald.conf">/etc/systemd/journald.conf</div><pre class="code-pre "><code class="code-highlight language-bash">. . .
[Journal]
Storage=<span class="highlight">persistent</span>
</code></pre>
<p>Если на вашем сервере включено хранение журналов предыдущих сеансов загрузки, утилита <code>journalctl</code> предоставит ряд команд, которые помогут работать с сеансами загрузки как с единицами хранения.  Чтобы просмотреть сеансы загрузки, о которых известно <code>journald</code>, используйте опцию <code>--list-boots</code> с командой <code>journalctl</code>:</p>
<pre class="code-pre "><code>journalctl --list-boots
</code></pre><pre class="code-pre "><code>-2 caf0524a1d394ce0bdbcff75b94444fe Tue 2015-02-03 21:48:52 UTC—Tue 2015-02-03 22:17:00 UTC
-1 13883d180dc0420db0abcb5fa26d6198 Tue 2015-02-03 22:17:03 UTC—Tue 2015-02-03 22:19:08 UTC
 0 bed718b17a73415fade0e4e7f4bea609 Tue 2015-02-03 22:19:12 UTC—Tue 2015-02-03 23:01:01 UTC
</code></pre>
<p>С этой опцией команда будет выводить по одной строке для каждого сеанса загрузки.  Первый столбец — это относительный идентификатор сеанса загрузки, который удобно использовать для ссылки на сеанс загрузки с помощью <code>journalctl</code>.  Если вам требуется абсолютный идентификатор, используйте значение boot ID во втором столбце.  Два поля времени ближе к концу строки позволяют определить время сеанса загрузки.</p>

<p>Чтобы вывести информацию из этих сеансов загрузки, вы можете использовать информацию из первого или второго столбца.</p>

<p>Например, чтобы просмотреть журнал предыдущей загрузки, используйте относительный указатель <code>-1</code> с флагом <code>-b</code>:</p>
<pre class="code-pre "><code>journalctl -b -1
</code></pre>
<p>Также вы можете использовать идентификатор сеанса загрузки для получения данных по сеансу загрузки:</p>
<pre class="code-pre "><code>journalctl -b caf0524a1d394ce0bdbcff75b94444fe
</code></pre>
<h3 id="Временные-окна">Временные окна</h3>

<p>Хотя возможность сортировки записей журнала по сеансам загрузки очень полезна, довольно часто вам могут потребоваться данные за периоды, не соответствующие сеансам загрузки системы.  Это может быть особенно актуально для серверов, которые долгое время работают без перезагрузки.</p>

<p>Для фильтрации временных окон можно использовать опции <code>--since</code> и <code>--until</code>, которые ограничивают вывод записями после или до указанного времени соответственно.</p>

<p>Значения времени могут иметь разные форматы.  Для абсолютных значений времени нужно использовать следующий формат:</p>
<pre class="code-pre "><code>YYYY-MM-DD HH:MM:SS
</code></pre>
<p>Например, чтобы просмотреть все записи с 10 января 2015 г. 17:15, мы введем:</p>
<pre class="code-pre "><code>journalctl --since "2015-01-10 17:15:00"
</code></pre>
<p>Если какие-то компоненты вышеописанного формата будут пропущены, будут применены значения по умолчанию.  Например, если дата не будет указана, по умолчанию будет использоваться текущая дата.  Если компонент времени отсутствует, для замены будет использоваться значение &ldquo;00:00:00&rdquo; (полночь).  Поле секунд можно опустить, и тогда для него будет по умолчанию использовано значение &ldquo;00&rdquo;:</p>
<pre class="code-pre "><code>journalctl --since "2015-01-10" --until "2015-01-11 03:00"
</code></pre>
<p>Журнальная система также понимает определенные относительные значения и именованные ярлыки.  Например, вы можете использовать слова &ldquo;yesterday&rdquo; (вчера), &ldquo;today&rdquo; (сегодня), &ldquo;tomorrow&rdquo;(завтра), &ldquo;now&rdquo; (сейчас) и т. д.  Чтобы указать относительное время, следует использовать префикс «-» или «+» перед числовым значением или использовать такие слова, как «ago» (назад) при построении фраз.</p>

<p>Чтобы получить данные за вчерашний день, введите:</p>
<pre class="code-pre "><code>journalctl --since yesterday
</code></pre>
<p>Если вы получили отчеты о перебоях в работе службы, которые начались в 9:00 и закончились час назад, вы можете ввести следующую команду:</p>
<pre class="code-pre "><code>journalctl --since 09:00 --until "1 hour ago"
</code></pre>
<p>Как видите, вы можете достаточно легко задавать гибкие временные интервалы для фильтрации записей, которые вам нужны.</p>

<h2 id="Фильтрация-по-значимости-сообщений">Фильтрация по значимости сообщений</h2>

<p>Мы изучили несколько возможных способов фильтрации записей в журнальной системе по временным рамкам.  В этом разделе мы поговорим о фильтрации сообщений по значимым для вас службам или компонентам.  Журнал <code>systemd</code> предоставляет много разных способов делать это.</p>

<h3 id="По-единицам">По единицам</h3>

<p>Возможно одним из наиболее полезных способов фильтрации является фильтрация по единицам, которые вас интересуют.  Для такой фильтрации мы можем использовать опцию <code>-u</code>.</p>

<p>Например, чтобы посмотреть все журналы единицы Nginx в нашей системе, мы можем ввести команду:</p>
<pre class="code-pre "><code>journalctl -u nginx.service
</code></pre>
<p>Обычно при этом также используется фильтрация по времени, чтобы вывести строки, которые вас интересуют.  Например, чтобы проверить, как служба работает сегодня, можно ввести команду:</p>
<pre class="code-pre "><code>journalctl -u nginx.service --since today
</code></pre>
<p>Такая фокусировка особенно полезна, если вы используете возможности чередования записей разных единиц в журнальной системе.  Например, если ваш процесс Nginx использует единицу PHP-FPM для обработки динамического контента, вы можете объединить их данные в хронологическом порядке, указав обе единицы:</p>
<pre class="code-pre "><code>journalctl -u nginx.service -u php-fpm.service --since today
</code></pre>
<p>Это облегчает поиск взаимодействия между разными программами, позволяя отлаживать целые системы вместо отдельных процессов.</p>

<h3 id="По-процессу-пользователю-или-идентификатору-группы">По процессу, пользователю или идентификатору группы</h3>

<p>Некоторые службы создают для своей работы множество разнообразных дочерних процессов.  Если вы определили точное значение PID интересующего вас процесса, вы можете использовать его как критерий фильтрации.</p>

<p>Для этого нужно указать при фильтрации поле <code>_PID</code>.  Например, если нас интересует PID 8088, мы можем ввести:</p>
<pre class="code-pre "><code>journalctl _PID=8088
</code></pre>
<p>В других случаях нам может понадобиться вывести все записи, зарегистрированные для определенного пользователя или группы.  Это можно сделать с помощью фильтров <code>_UID</code> или <code>_GID</code>.  Например, если ваш веб-сервер работает под именем пользователя <code>www-data</code>, вы можете найти идентификатор пользователя с помощью следующей команды:</p>
<pre class="code-pre "><code>id -u www-data
</code></pre><pre class="code-pre "><code>33
</code></pre>
<p>После этого, вы сможете использовать возвращенный идентификатор для фильтрации результатов журнальной системы:</p>
<pre class="code-pre "><code>journalctl _UID=<span class="highlight">33</span> --since today
</code></pre>
<p>Журнал <code>systemd</code> содержит множество полей, которые можно использовать для фильтрации.  Некоторые из них передаются от регистрируемого процесса и применяются <code>journald</code> с использованием информации, собираемой из системы в указанное в журнале время.</p>

<p>Символ подчеркивания в начале указывает, что поле <code>_PID</code> относится к последнему типу.  Журнал автоматически регистрирует и индексирует значения PID процессов, регистрируемых для последующей фильтрации.  Вы можете узнать все о доступных полях журнала, используя следующую команду:</p>
<pre class="code-pre "><code>man systemd.journal-fields
</code></pre>
<p>В этом руководстве мы обсудим это более подробно.  Сейчас же мы рассмотрим более полезную опцию, связанную с фильтрацией по этим полям.  Опцию <code>-F</code> можно использовать, чтобы вывести все доступные значения для указанного поля журнальной системы.</p>

<p>Например, чтобы посмотреть, для каких идентификаторов групп существуют записи в журнальной системе <code>systemd</code>, вы можете ввести следующую команду:</p>
<pre class="code-pre "><code>journalctl -F _GID
</code></pre><pre class="code-pre "><code>32
99
102
133
81
84
100
0
124
87
</code></pre>
<p>Она покажет вам все значения, сохраненные в журнальной системе для поля group ID.  Это должно помочь вам в настройке фильтров.</p>

<h3 id="По-пути-компонента">По пути компонента</h3>

<p>Также для фильтрации можно указать путь.</p>

<p>Если путь указывает на исполняемый файл, <code>journalctl</code> выведет все записи, связанные с этим исполняемым файлом.  Например, чтобы найти записи с исполняемым файлом <code>bash</code>, нужно ввести команду:</p>
<pre class="code-pre "><code>journalctl /usr/bin/bash
</code></pre>
<p>Обычно, если единица доступна для исполняемого файла, этот метод проще и удобнее и дает более полезную информацию (записи связанных дочерних процессов и т. д.).  В некоторых случаях это невозможно.</p>

<h3 id="Отображение-сообщений-ядра">Отображение сообщений ядра</h3>

<p>Также из журнальной системы можно получить сообщения ядра, обычно содержащиеся в выводе <code>dmesg</code>.</p>

<p>Чтобы вывести только эти сообщения, можно добавить к команде флаг <code>-k</code> или <code>--dmesg</code>:</p>
<pre class="code-pre "><code>journalctl -k
</code></pre>
<p>По умолчанию отображаются только сообщения ядра из текущего сеанса загрузки.  При этом вы можете указать другой сеанс загрузки, используя описанные выше флаги выбора загрузки. Например, чтобы получить сообщения пятого по счету сеанса загрузки, начиная с текущего, можно ввести команду:</p>
<pre class="code-pre "><code>journalctl -k -b -5
</code></pre>
<h3 id="По-приоритету">По приоритету</h3>

<p>Приоритет сообщений — один из тех критериев фильтрации, которые больше всего интересны системным администраторам.  Хотя регистрация в журнале развернутой информации обычно полезна, при чтении этой информации записи с низким приоритетом могут отвлечь или запутать.</p>

<p>Вы можете использовать <code>journalctl</code> с опцией <code>-p</code>, чтобы вывести только сообщения с указанным или более высоким приоритетом.  Это позволяет убрать из выводимых результатов сообщения с более низким приоритетом.</p>

<p>Например, чтобы вывести только записи с уровнем серьезности error (ошибка) или выше, введите команду:</p>
<pre class="code-pre "><code>journalctl -p err -b
</code></pre>
<p>Эта команда покажет вам все сообщения с пометкой error (ошибка), critical (критическая ошибка), alert (тревога) или emergency (чрезвычайная ситуация).  В журнальной системе реализованы стандартные уровни ошибок <code>syslog</code>.  Вы можете использовать название уровня приоритета или соответствующее числовое значение.  Вот эти значения, от наибольшего приоритета к наименьшему:</p>

<ul>
<li>0: emerg</li>
<li>1: alert</li>
<li>2: crit</li>
<li>3: err</li>
<li>4: warning</li>
<li>5: notice</li>
<li>6: info</li>
<li>7: debug</li>
</ul>

<p>Вышеуказанные числа или названия можно использовать с опцией <code>-p</code> как взаимозаменяемые.  При выборе приоритета будут выведены сообщения указанного уровня и более высоких уровней.</p>

<h2 id="Изменение-отображения-журнальной-системы">Изменение отображения журнальной системы</h2>

<p>Выше мы продемонстрировали выбор записей посредством фильтрации.  Однако есть и другие способы, позволяющие изменить вывод.  Мы можем настраивать отображение <code>journalctl</code> для различных целей.</p>

<h3 id="Сокращение-или-расширение-области-вывода">Сокращение или расширение области вывода</h3>

<p>Мы можем настроить вид вывода данных <code>journalctl</code>, указав, что вывод можно сжать или раскрыть.</p>

<p>По умолчанию <code>journalctl</code> выводит на страничном модуле всю запись целиком так, что записи доходят до правого края экрана.  Для доступа к этой информации следует нажать правую стрелку.</p>

<p>Если вы предпочитаете урезать вывод и вставить многоточие в месте, где удалена информация, вы можете использовать опцию <code>--no-full</code>:</p>
<pre class="code-pre "><code>journalctl --no-full
</code></pre><pre class="code-pre "><code>. . .

Feb 04 20:54:13 journalme sshd[937]: Failed password for root from 83.234.207.60...h2
Feb 04 20:54:13 journalme sshd[937]: Connection closed by 83.234.207.60 [preauth]
Feb 04 20:54:13 journalme sshd[937]: PAM 2 more authentication failures; logname...ot
</code></pre>
<p>Также вы можете сделать и обратное, и попросить <code>journalctl</code> вывести всю доступную информацию вне зависимости от того, содержит ли она непечатные символы.  Для этого можно использовать флаг <code>-a</code>:</p>
<pre class="code-pre "><code>journalctl -a
</code></pre>
<h3 id="Вывод-в-стандартный-выход">Вывод в стандартный выход</h3>

<p>По умолчанию <code>journalctl</code> показывает вывод на многостраничной панели, чтобы упростить чтение информации.  Однако, если вы планируете обработать данные в текстовом редакторе, вероятно для вас будет более предпочтительным стандартный вывод.</p>

<p>Для такого вывода следует использовать опцию <code>--no-pager</code>:</p>
<pre class="code-pre "><code>journalctl --no-pager
</code></pre>
<p>Полученные данные можно немедленно передать в утилиту обработки или сохранить в файле на диске в зависимости от того, что вам требуется.</p>

<h3 id="Форматы-вывода">Форматы вывода</h3>

<p>Если вы обрабатываете записи журнала, как указано выше, вам вероятно будет проще анализировать данные в более удобном формате.  К счастью, журнал можно выводить в множестве разных форматов.  Для этого вы можете использовать опцию <code>-o</code> вместе с указателем формата.</p>

<p>Например, чтобы вывести журнала в формате JSON, нужно ввести следующую команду:</p>
<pre class="code-pre "><code>journalctl -b -u nginx -o json
</code></pre><pre class="code-pre "><code>{ "__CURSOR" : "s=13a21661cf4948289c63075db6c25c00;i=116f1;b=81b58db8fd9046ab9f847ddb82a2fa2d;m=19f0daa;t=50e33c33587ae;x=e307daadb4858635", "__REALTIME_TIMESTAMP" : "1422990364739502", "__MONOTONIC_TIMESTAMP" : "27200938", "_BOOT_ID" : "81b58db8fd9046ab9f847ddb82a2fa2d", "PRIORITY" : "6", "_UID" : "0", "_GID" : "0", "_CAP_EFFECTIVE" : "3fffffffff", "_MACHINE_ID" : "752737531a9d1a9c1e3cb52a4ab967ee", "_HOSTNAME" : "desktop", "SYSLOG_FACILITY" : "3", "CODE_FILE" : "src/core/unit.c", "CODE_LINE" : "1402", "CODE_FUNCTION" : "unit_status_log_starting_stopping_reloading", "SYSLOG_IDENTIFIER" : "systemd", "MESSAGE_ID" : "7d4958e842da4a758f6c1cdc7b36dcc5", "_TRANSPORT" : "journal", "_PID" : "1", "_COMM" : "systemd", "_EXE" : "/usr/lib/systemd/systemd", "_CMDLINE" : "/usr/lib/systemd/systemd", "_SYSTEMD_CGROUP" : "/", "UNIT" : "nginx.service", "MESSAGE" : "Starting A high performance web server and a reverse proxy server...", "_SOURCE_REALTIME_TIMESTAMP" : "1422990364737973" }

. . .
</code></pre>
<p>Это полезно, если вы используете утилиты для синтаксического анализа.  Вы можете использовать формат <code>json-pretty</code>, чтобы сделать структуру данных проще, прежде чем передавать данные потребителю JSON:</p>
<pre class="code-pre "><code>journalctl -b -u nginx -o json-pretty
</code></pre><pre class="code-pre "><code>{
    "__CURSOR" : "s=13a21661cf4948289c63075db6c25c00;i=116f1;b=81b58db8fd9046ab9f847ddb82a2fa2d;m=19f0daa;t=50e33c33587ae;x=e307daadb4858635",
    "__REALTIME_TIMESTAMP" : "1422990364739502",
    "__MONOTONIC_TIMESTAMP" : "27200938",
    "_BOOT_ID" : "81b58db8fd9046ab9f847ddb82a2fa2d",
    "PRIORITY" : "6",
    "_UID" : "0",
    "_GID" : "0",
    "_CAP_EFFECTIVE" : "3fffffffff",
    "_MACHINE_ID" : "752737531a9d1a9c1e3cb52a4ab967ee",
    "_HOSTNAME" : "desktop",
    "SYSLOG_FACILITY" : "3",
    "CODE_FILE" : "src/core/unit.c",
    "CODE_LINE" : "1402",
    "CODE_FUNCTION" : "unit_status_log_starting_stopping_reloading",
    "SYSLOG_IDENTIFIER" : "systemd",
    "MESSAGE_ID" : "7d4958e842da4a758f6c1cdc7b36dcc5",
    "_TRANSPORT" : "journal",
    "_PID" : "1",
    "_COMM" : "systemd",
    "_EXE" : "/usr/lib/systemd/systemd",
    "_CMDLINE" : "/usr/lib/systemd/systemd",
    "_SYSTEMD_CGROUP" : "/",
    "UNIT" : "nginx.service",
    "MESSAGE" : "Starting A high performance web server and a reverse proxy server...",
    "_SOURCE_REALTIME_TIMESTAMP" : "1422990364737973"
}

. . .
</code></pre>
<p>Для отображения можно использовать следующие форматы:</p>

<ul>
<li><strong>cat</strong>: отображает только само поле сообщения.</li>
<li><strong>export</strong>: двоичный формат, подходящий для передачи или резервного копирования.</li>
<li><strong>json</strong>: стандартный формат JSON с одной записью на строку.</li>
<li><strong>json-pretty</strong>: код JSON в формате, более удобном для чтения человеком</li>
<li><strong>json-sse</strong>: вывод в формате JSON в оболочке, совместимой с операцией add server-sent event</li>
<li><strong>short</strong>: вывод в формате <code>syslog</code> по умолчанию</li>
<li><strong>short-iso</strong>: формат по умолчанию, дополненный для отображения временных меток часов ISO 8601.</li>
<li><strong>short-monotonic</strong>: формат по умолчанию с однотонными временными метками.</li>
<li><strong>short-precise</strong>: формат по умолчанию с точностью до микросекунд</li>
<li><strong>verbose</strong>: показывает все поля журнальной системы, доступные для ввода, в том числе те, которые обычно скрыты на внутреннем уровне.</li>
</ul>

<p>Эти опции позволяют выводить записи журнала в любом формате, который лучше всего соответствует вашим текущим потребностям.</p>

<h2 id="Мониторинг-активных-процессов">Мониторинг активных процессов</h2>

<p>Команда <code>journalctl</code> имитирует, сколько администраторов используют <code>tail</code> для мониторинга активных процессов или недавней активности.  Эта функция встроена в <code>journalctl</code>, обеспечивая доступ к этим возможностям без подключения другого инструмента.</p>

<h3 id="Отображение-последних-журналов">Отображение последних журналов</h3>

<p>Чтобы вывести указанное количество записей, вы можете использовать опцию <code>-n</code>, которая работает как <code>tail -n</code>.</p>

<p>По умолчанию отображается 10 последних записей:</p>
<pre class="code-pre "><code>journalctl -n
</code></pre>
<p>Вы можете указать желаемое количество записей, задав число после <code>-n</code>:</p>
<pre class="code-pre "><code>journalctl -n 20
</code></pre>
<h3 id="Наблюдение-за-журналами">Наблюдение за журналами</h3>

<p>Для активного наблюдения за журналами по мере их пополнения можно использовать флаг <code>-f</code>.  Это будет работать именно так, как можно ожидать, если у вас есть опыт использования <code>tail -f</code>:</p>
<pre class="code-pre "><code>journalctl -f
</code></pre>
<h2 id="Обслуживание-журналов">Обслуживание журналов</h2>

<p>Вам может быть интересно, сколько места занимают все эти данные, которые мы уже видели.  Более того, вы можете захотеть удалить какие-либо старые журналы и освободить место.</p>

<h3 id="Определение-текущего-использования-дискового-пространства">Определение текущего использования дискового пространства</h3>

<p>Вы можете определить, сколько места занимает журнал на диске, используя флаг <code>--disk-usage</code>:</p>
<pre class="code-pre "><code>journalctl --disk-usage
</code></pre><pre class="code-pre "><code>Journals take up 8.0M on disk.
</code></pre>
<h3 id="Удаление-старых-журналов">Удаление старых журналов</h3>

<p>Если вы хотите сократить размер журнала, вы можете использовать для этого два разных способа (доступных в <code>systemd</code> версии 218 или выше).</p>

<p>Если вы используете опцию <code>--vacuum-size</code>, вы можете сократить журнал, указав размер.  При использовании этой опции старые записи будут удаляться, пока занимаемое журнальной системой место на диске не сократится до требуемого размера:</p>
<pre class="code-pre "><code>sudo journalctl --vacuum-size=1G
</code></pre>
<p>Также можно сократить размер журнала, указав время отсечки с помощью <code>--vacuum-time</code>.  Любые записи вне этого времени удаляются.  Эта опция позволяет сохранить записи, созданные после истечения определенного времени.</p>

<p>Например, чтобы сохранить записи с прошлого года, вы можете ввести:</p>
<pre class="code-pre "><code>sudo journalctl --vacuum-time=1years
</code></pre>
<h3 id="Ограничение-расширения-журналов">Ограничение расширения журналов</h3>

<p>Вы можете настроить свой сервер так, чтобы ограничить место, занимаемое журнальной системой.  Для этого следует отредактировать файл <code>/etc/systemd/journald.conf</code>.</p>

<p>Для ограничения роста занимаемого журнальной системой объема можно использовать следующие элементы:</p>

<ul>
<li><strong><code>SystemMaxUse=</code></strong>: указывает максимальное пространство на диске, которое может использоваться журнальной системой.</li>
<li><strong><code>SystemKeepFree=</code></strong>: указывает пространство на диске, которое журнальная система должна оставлять свободным при добавлении записей в журналы.</li>
<li><strong><code>SystemMaxFileSize=</code></strong>: определяет, до какого размера могут увеличиваться большие файлы журнала на диске до ротации.</li>
<li><strong><code>RuntimeMaxUse=</code></strong>: указывает, сколько места на диске может использоваться для временного хранения (в <code>/run</code> filesystem).</li>
<li><strong><code>RuntimeKeepFree=</code></strong>: указывает, сколько места на диске следует оставлять на диске для других целей при записи данных во временное хранилище (в файловой системе <code>/run</code>).</li>
<li><strong><code>RuntimeMaxFileSize=</code></strong>: указывает, сколько места может занимать отдельный файл журнала во временном хранилище (в файловой системе <code>/run</code>) до ротации.</li>
</ul>

<p>Задавая эти значения, вы можете контролировать, сколько места на вашем сервере использует <code>journald</code>.  Помните, что <strong><code>SystemMaxFileSize</code></strong> и <strong><code>RuntimeMaxFileSize</code></strong> будут применяться к архивным файлам для достижения заданных ограничений. Это важно помнить при интерпретации подсчета файлов после операции вакуумной очистки.</p>

<h2 id="Заключение">Заключение</h2>

<p>Как видите, журнальная система <code>systemd</code> очень полезна для сбора данных о вашей системе и приложениях и для управления этими данными. Гибкость в основном обеспечивается за счет автоматической регистрации большого количества метаданных и централизованной структуры журналов. Команда <code>journalctl</code> позволяет легко использовать расширенные функции журнальной системы и проводить расширенный анализ и реляционную отладку разных компонентов приложения.</p>
