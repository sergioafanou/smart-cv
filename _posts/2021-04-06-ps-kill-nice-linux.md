---
title : "Использование ps, kill и nice для управления процессами в Linux"
layout: post
tags: tutorial labnol
post_inspiration: https://www.digitalocean.com/community/tutorials/how-to-use-ps-kill-and-nice-to-manage-processes-in-linux-ru
image: "https://sergio.afanou.com/assets/images/image-midres-42.jpg"
---

<h3 id="Введение">Введение</h3>

<hr>

<p>Сервер Linux, как и любой другой компьютер, использует приложения. Компьютер рассматривает эти приложения как процессы.</p>

<p>Хотя Linux автоматически выполняет все скрытые низкоуровневые задачи жизненного цикла процесса, нам необходим способ взаимодействия с операционной системой для управления на более высоком уровне.</p>

<p>В этом учебном модуле мы расскажем о некоторых простых аспектах управления процессами. Linux предоставляет широкий выбор инструментов для этой цели.</p>

<p>В качестве примера мы используем Ubuntu 12.04 VPS, но любые современные дистрибутивы Linux будут работать аналогичным образом.</p>

<h2 id="Просмотр-запущенных-процессов-в-linux">Просмотр запущенных процессов в Linux</h2>

<hr>

<h3 id="top">top</h3>

<hr>

<p>Чтобы посмотреть, какие процессы запущены на вашем сервере, нужно запустить команду <code>top</code>:</p>
<pre class="code-pre "><code>top***

top - 15:14:40 up 46 min,  1 user,  load average: 0.00, 0.01, 0.05 Tasks:  56 total,   1 running,  55 sleeping,   0 stopped,   0 zombie Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st Mem:   1019600k total,   316576k used,   703024k free,     7652k buffers Swap:        0k total,        0k used,        0k free,   258976k cached   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND               1 root      20   0 24188 2120 1300 S  0.0  0.2   0:00.56 init                   2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd               3 root      20   0     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/0            6 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0            7 root      RT   0     0    0    0 S  0.0  0.0   0:00.03 watchdog/0             8 root       0 -20     0    0    0 S  0.0  0.0   0:00.00 cpuset                 9 root       0 -20     0    0    0 S  0.0  0.0   0:00.00 khelper               10 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kdevtmpfs          
</code></pre>
<p>В верхней части подборки приведена статистика по системе, в том числе сведения о нагрузке и общем количестве задач.</p>

<p>Вы можете легко увидеть, что в системе запущен 1 процесс, а 55 процессов находятся в режиме сна (т. е. не активны/не используют ресурсы ЦП).</p>

<p>В нижней части отображаются запущенные процессы и статистика их использования.</p>

<h3 id="htop">htop</h3>

<hr>

<p>В репозиториях доступна улучшенная версия <code>top</code>, которая называется <code>htop</code>.  Установите ее с помощью следующей команды:</p>
<pre class="code-pre "><code>sudo apt-get install htop
</code></pre>
<p>Если мы запустим команду <code>htop</code>, мы увидим отображение информации в более удобном формате:</p>
<pre class="code-pre "><code>htop***

  Mem[|||||||||||           49/995MB]     Load average: 0.00 0.03 0.05   CPU[                          0.0%]     Tasks: 21, 3 thr; 1 running   Swp[                         0/0MB]     Uptime: 00:58:11   PID USER      PRI  NI  VIRT   RES   SHR S CPU% MEM%   TIME+  Command  1259 root       20   0 25660  1880  1368 R  0.0  0.2  0:00.06 htop     1 root       20   0 24188  2120  1300 S  0.0  0.2  0:00.56 /sbin/init   311 root       20   0 17224   636   440 S  0.0  0.1  0:00.07 upstart-udev-brid   314 root       20   0 21592  1280   760 S  0.0  0.1  0:00.06 /sbin/udevd --dae   389 messagebu  20   0 23808   688   444 S  0.0  0.1  0:00.01 dbus-daemon --sys   407 syslog     20   0  243M  1404  1080 S  0.0  0.1  0:00.02 rsyslogd -c5   408 syslog     20   0  243M  1404  1080 S  0.0  0.1  0:00.00 rsyslogd -c5   409 syslog     20   0  243M  1404  1080 S  0.0  0.1  0:00.00 rsyslogd -c5   406 syslog     20   0  243M  1404  1080 S  0.0  0.1  0:00.04 rsyslogd -c5   553 root       20   0 15180   400   204 S  0.0  0.0  0:00.01 upstart-socket-br
</code></pre>
<p>Вы можете <a href="https://www.digitalocean.com/community/articles/how-to-use-top-netstat-du-other-tools-to-monitor-server-resources#process">узнать больше об использовании top и htop</a> здесь.</p>

<h2 id="Использование-ps-для-вывода-перечня-процессов">Использование ps для вывода перечня процессов</h2>

<hr>

<p>И <code>top</code>, и <code>htop</code> предоставляют удобный интерфейс для просмотра работающих процессов, похожий на графический диспетчер задач.</p>

<p>Однако эти инструменты не всегда достаточно гибкие, чтобы охватывать все сценарии.  Решить эту проблему может помочь мощная команда <code>ps</code>.</p>

<p>При вызове без аргументов вывод может быть довольно сжатым:</p>
<pre class="code-pre "><code>ps***

  PID TTY          TIME CMD  1017 pts/0    00:00:00 bash  1262 pts/0    00:00:00 ps
</code></pre>
<p>Вывод показывает все процессы, связанные с текущим пользователем и текущим сеансом терминала.  Это имеет смысл, потому что мы запускаем на этом терминале только <code>bash</code> и <code>ps</code>.</p>

<p>Чтобы получить более полное представление о процессах в данной системе, мы можем использовать следующую команду:</p>
<pre class="code-pre "><code>ps aux***

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND root         1  0.0  0.2  24188  2120 ?        Ss   14:28   0:00 /sbin/init root         2  0.0  0.0      0     0 ?        S    14:28   0:00 [kthreadd] root         3  0.0  0.0      0     0 ?        S    14:28   0:00 [ksoftirqd/0] root         6  0.0  0.0      0     0 ?        S    14:28   0:00 [migration/0] root         7  0.0  0.0      0     0 ?        S    14:28   0:00 [watchdog/0] root         8  0.0  0.0      0     0 ?        S&lt;   14:28   0:00 [cpuset] root         9  0.0  0.0      0     0 ?        S&lt;   14:28   0:00 [khelper] . . .
</code></pre>
<p>Эти опции предписывают <code>ps</code> показать процессы, принадлежащие всем пользователям (вне зависимости от привязки терминала) в удобном формате.</p>

<p>Чтобы посмотреть представление <em>дерева</em> с иллюстрацией иерархических отношений, данную команду можно запустить с этими опциями:</p>
<pre class="code-pre "><code>ps axjf***

 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND     0     2     0     0 ?           -1 S        0   0:00 [kthreadd]     2     3     0     0 ?           -1 S        0   0:00  \_ [ksoftirqd/0]     2     6     0     0 ?           -1 S        0   0:00  \_ [migration/0]     2     7     0     0 ?           -1 S        0   0:00  \_ [watchdog/0]     2     8     0     0 ?           -1 S&lt;       0   0:00  \_ [cpuset]     2     9     0     0 ?           -1 S&lt;       0   0:00  \_ [khelper]     2    10     0     0 ?           -1 S        0   0:00  \_ [kdevtmpfs]     2    11     0     0 ?           -1 S&lt;       0   0:00  \_ [netns] . . .
</code></pre>
<p>Как видите, процесс <code>kthreadd</code> отображается как родитель процесса <code>ksoftirqd/0</code> и других процессов.</p>

<h3 id="Примечание-об-идентификаторах-процессов">Примечание об идентификаторах процессов</h3>

<hr>

<p>В системах Linux и Unix каждому процессу назначается <strong>идентификатор процесса</strong> или <strong>PID</strong>.  Операционная система использует их для идентификации и отслеживания процессов.</p>

<p>Чтобы быстро узнать PID процесса, вы можете использовать команду <code>pgrep</code>:</p>
<pre class="code-pre "><code>pgrep bash***

1017
</code></pre>
<p>Эта команда просто запросит идентификатор процесса и выведет его.</p>

<p>Процессу <em>init</em>, который создается первым при загрузке, присваивается PID &ldquo;1&rdquo;.</p>
<pre class="code-pre "><code>pgrep init***

1
</code></pre>
<p>Этот процесс отвечает за создание всех остальных процессов в системе.  Последующим процессам присваиваются большие номера PID.</p>

<p><em>Родитель</em> процесса — это процесс, который отвечает за его создание. Родительские процессы имеют идентификатор <strong>PPID</strong>, который можно увидеть в заголовках столбцов многих приложений для управления процессами, включая <code>top</code>, <code>htop</code> и <code>ps</code>.</p>

<p>Любое взаимодействие между пользователем и операционной системой, связанное с процессами, включает взаимное преобразование имен процессов и PID. Именно поэтому утилиты сообщают вам PID.</p>

<h3 id="Отношения-родительских-и-дочерних-элементов">Отношения родительских и дочерних элементов</h3>

<hr>

<p>Создание дочернего процесса осуществляется в два этапа: fork() создает новое адресное пространство и копирует в него ресурсы, принадлежащие родительскому процессу, с помощью copy-on-write; а exec() загружает исполняемый блок в адресное пространство и выполняет его.</p>

<p>Если дочерний процесс завершается раньше родительского, он остается бесхозным, пока родитель не получит информацию о нем или не сообщит ядру, что эта информация не требуется. В этом случае ресурсы дочернего процесса освободятся. Если родительский процесс завершается раньше дочернего, дочерний процесс привязывается к процессу init, хотя его можно переназначить другому процессу.</p>

<h2 id="Отправка-сигналов-процессам-в-linux">Отправка сигналов процессам в Linux</h2>

<hr>

<p>Все процессы Linux реагируют на <em>сигналы</em>.  Операционная система использует сигналы, чтобы отправить программам команду остановиться или изменить поведение.</p>

<h3 id="Отправка-сигналов-процессам-по-pid">Отправка сигналов процессам по PID</h3>

<hr>

<p>Наиболее распространенный способ передачи сигналов в программу — использовать команду <code>kill</code>.</p>

<p>Как вы можете догадаться, по умолчанию эта утилита пытается уничтожить процесс:</p>

<p>&lt;pre&gt;kill &lt;span class=&ldquo;highlight&rdquo;&gt;PID<em>of</em>target_process&lt;/span&gt;&lt;/pre&gt;</p>

<p>Она отправляет процессору сигнал <strong>TERM</strong>.  Сигнал TERM просит процесс остановиться.  Это позволяет программе выполнить операции по очистке и нормально завершить работу.</p>

<p>Если программа работает неправильно и не завершает работу после получения сигнала TERM, мы можем отправить сигнал более высокого уровня — <code>KILL</code>:</p>

<p>&lt;pre&gt;kill -KILL &lt;span class=&ldquo;highlight&rdquo;&gt;PID<em>of</em>target_process&lt;/span&gt;&lt;/pre&gt;</p>

<p>Это специальный сигнал, который не отправляется программе.</p>

<p>Вместо этого он передается в ядро операционной системы, которое отключает процесс. Он используется, чтобы обходить программы, игнорирующие отправляемые им сигналы.</p>

<p>Каждому сигналу присвоено число, которое можно передать вместо имени. Например, вы можете передать &ldquo;-15&rdquo; вместо &ldquo;-TERM&rdquo; и &ldquo;-9&rdquo; вместо &ldquo;-KILL&rdquo;.</p>

<h3 id="Использование-сигналов-для-других-целей">Использование сигналов для других целей</h3>

<hr>

<p>Сигналы используются не только для отключения программ. Их также можно использовать для выполнения других действий.</p>

<p>Например, многие демоны перезапускаются при получении сигнала <code>HUP</code> или прекращения работы.  Например, так работает Apache.</p>

<p>&lt;pre&gt;sudo kill -HUP &lt;span class=&ldquo;highlight&rdquo;&gt;pid<em>of</em>apache&lt;/span&gt;&lt;/pre&gt;</p>

<p>Получив вышеуказанную команду, Apache перезагрузит файл конфигурации и возобновит вывод контента.</p>

<p>Вы можете вывести список сигналов, которые можно отправлять с помощью kill, используя следующую команду:</p>
<pre class="code-pre "><code>kill -l***

1) SIGHUP    2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP  6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM . . .
</code></pre>
<h3 id="Отправка-сигналов-процессам-по-имени">Отправка сигналов процессам по имени</h3>

<hr>

<p>Хотя обычно при отправке сигналов используются PID, существуют способы использовать для этой же цели обычные имена процессов.</p>

<p>Команда <code>pkill</code> работает практически точно так же как и <code>kill</code>, но использует имя процесса:</p>
<pre class="code-pre "><code>pkill -9 ping
</code></pre>
<p>Вышеуказанная команда эквивалентна команде:</p>
<pre class="code-pre "><code>kill -9 `pgrep ping`
</code></pre>
<p>Если вы хотите отправить сигнал каждому экземпляру определенного процесса, вы можете использовать команду <code>killall</code>:</p>
<pre class="code-pre "><code>killall firefox
</code></pre>
<p>Приведенная выше команда отправит сигнал TERM всем экземплярам firefox, запущенным на этом компьютере.</p>

<h2 id="Настройка-приоритетов-процессов">Настройка приоритетов процессов</h2>

<hr>

<p>Часто бывает необходимо изменить приоритет процессов в серверной среде.</p>

<p>Некоторые процессоры могут быть важными, а другие могут выполняться на излишках ресурсов.</p>

<p>Linux контролирует приоритеты с помощью значения <strong>вежливости</strong>.</p>

<p>Приоритетные задачи считаются менее <em>вежливыми</em>, потому что они вообще не делятся ресурсами.  Процессы с низким приоритетом считаются <em>более вежливыми</em>, потому что они используют минимум ресурсов.</p>

<p>Когда мы запускали команду <code>top</code> в начале этого учебного модуля, мы видели столбец &ldquo;NI&rdquo;.  В этом столбце отображается значение <em>вежливости</em> процесса:</p>
<pre class="code-pre "><code>top***

 Tasks:  56 total,   1 running,  55 sleeping,   0 stopped,   0 zombie Cpu(s):  0.0%us,  0.3%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st Mem:   1019600k total,   324496k used,   695104k free,     8512k buffers Swap:        0k total,        0k used,        0k free,   264812k cached   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND            1635 root      20   0 17300 1200  920 R  0.3  0.1   0:00.01 top                    1 root      20   0 24188 2120 1300 S  0.0  0.2   0:00.56 init                   2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd               3 root      20   0     0    0    0 S  0.0  0.0   0:00.11 ksoftirqd/0
</code></pre>
<p>В зависимости от системы, значения вежливости могут различаться от &ldquo;-19/-20&rdquo; (наибольший приоритет) до &ldquo;19/20&rdquo; (наименьший приоритет).</p>

<p>Чтобы запустить программу с определенным значением вежливости, мы можем использовать команду <code>nice</code>:</p>

<p>&lt;pre&gt;nice -n 15 &lt;span class=&ldquo;highlight&rdquo;&gt;command<em>to</em>execute&lt;/span&gt;&lt;/pre&gt;</p>

<p>Это работает только в начале новой программы.</p>

<p>Чтобы изменить значение вежливости уже выполняемой программы, мы используем инструмент <code>renice</code>:</p>

<p>&lt;pre&gt;renice 0 &lt;span class=&ldquo;highlight&rdquo;&gt;PID<em>to</em>prioritize&lt;/span&gt;&lt;/pre&gt;</p>

<p><strong>Примечание. Хотя nice по необходимости использует имя команды, renice вызывает PID процесса.</strong></p>

<h2 id="Заключение">Заключение</h2>

<hr>

<p>Управление процессами — это тема, которая иногда бывает сложной для новых пользователей, потому что используемые для этой цели инструменты отличаются от аналогичных инструментов с графическим интерфейсом.</p>

<p>Однако все эти идеи знакомы, интуитивно понятны и станут привычными после небольшой практики.  Поскольку процессы используются в компьютерных системах повсеместно, умение эффективно управлять ими — критически важный навык.</p>

<p>&lt;div class=&ldquo;author&rdquo;&gt;Джастин Эллингвуд&lt;/div&gt;</p>
